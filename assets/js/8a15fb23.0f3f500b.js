"use strict";(globalThis.webpackChunkkonifer_docs=globalThis.webpackChunkkonifer_docs||[]).push([[161],{2636:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"Reference/image-processing-reference","title":"Image Processing Architecture","description":"Konifer leverages libvips as its underlying transformation engine. Libvips is a","source":"@site/docs/Reference/image-processing.md","sourceDirName":"Reference","slug":"/Reference/image-processing-reference","permalink":"/konifer-docs/Reference/image-processing-reference","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"id":"image-processing-reference","title":"Image Processing Architecture","sidebar_label":"Image Processing"},"sidebar":"docsSidebar","previous":{"title":"Image Transformation","permalink":"/konifer-docs/Reference/image-transformation-reference"},"next":{"title":"Storing Assets","permalink":"/konifer-docs/Reference/reference-variant-storage"}}');var s=i(4848),t=i(8453);const o={sidebar_position:3,id:"image-processing-reference",title:"Image Processing Architecture",sidebar_label:"Image Processing"},a="Image Processing Architecture",l={},c=[{value:"Memory Management",id:"memory-management",level:2},{value:"Managing Out of Memory Errors",id:"managing-out-of-memory-errors",level:3},{value:"Temporary Files",id:"temporary-files",level:2},{value:"Using a RAM disk (tmpfs)",id:"using-a-ram-disk-tmpfs",level:3},{value:"Using Outside Volume",id:"using-outside-volume",level:3},{value:"Variant Workers",id:"variant-workers",level:2},{value:"Concurrency Limit",id:"concurrency-limit",level:3},{value:"Configuration",id:"configuration",level:3},{value:"Scheduling &amp; Priority",id:"scheduling--priority",level:2},{value:"Priority",id:"priority",level:3},{value:"Configuring Priority",id:"configuring-priority",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"image-processing-architecture",children:"Image Processing Architecture"})}),"\n",(0,s.jsxs)(n.p,{children:["Konifer leverages ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://www.libvips.org/",children:"libvips"})})," as its underlying transformation engine. Libvips is a\ndemand-driven, streaming image processing library. Unlike traditional image processors (like ImageMagick), libvips does\nnot load the entire image into memory. Instead, it streams the image in small chunks, processing them via a pipeline."]}),"\n",(0,s.jsx)(n.p,{children:"This architecture allows Konifer to handle large assets (e.g., 100MB+ images) with a very small memory footprint and\nextremely low latency."}),"\n",(0,s.jsx)(n.admonition,{type:"caution",children:(0,s.jsx)(n.p,{children:"Libvips buffers the entire image if it is progressively-rendered JPEGs (image content is interlaced to provide a progressively-improving\ndisplay quality as the image is downloaded). Avoid ingestion of these images."})}),"\n",(0,s.jsx)(n.h2,{id:"memory-management",children:"Memory Management"}),"\n",(0,s.jsx)(n.p,{children:"Because Konifer is a Kotlin application running on the JVM (Netty) while utilizing libvips (C library) for processing, memory is managed in three distinct regions."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"JVM Heap"}),": Manages application logic, routing, and request metadata. Controlled by -Xmx."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Direct Memory (Off-Heap)"}),": Manages Netty IO buffers for network uploads. Controlled by -XX",":MaxDirectMemorySize","."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Native Memory (Off-Heap)"}),": Manages the actual image pixels processed by libvips. Not controlled by JVM flags."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"managing-out-of-memory-errors",children:"Managing Out of Memory Errors"}),"\n",(0,s.jsx)(n.p,{children:"If Konifer crashes, the error type determines the fix:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"OutOfMemoryError: Java heap space"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cause"}),": Application logic or metadata overhead has exhausted the Heap."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fix"}),": Increase JVM Heap using -Xmx or -XX",":MaxRAMPercentage","."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"OutOfMemoryError: Direct buffer memory"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cause"}),": Netty has exhausted IO buffers, likely due to high concurrent uploads."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fix"}),": Increase -XX",":MaxDirectMemorySize",". (Note: If unspecified, this often defaults to the Heap size)."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["Container ",(0,s.jsx)(n.code,{children:"OOMKilled"})," (Exit Code 137)"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cause"}),": libvips exhausted the remaining system RAM. The OS killed the container to save the host."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fix"}),": Increase the Container Memory Limit without increasing the JVM Heap (e.g., lower -XX",":MaxRAMPercentage",")."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"temporary-files",children:"Temporary Files"}),"\n",(0,s.jsxs)(n.p,{children:["Konifer makes extensive use of temporary files for image processing. By default, these are created inside the container's\nwritable layer, which can be slow. For improved performance, mount a fast volume (or RAM disk) to the ",(0,s.jsx)(n.code,{children:"/app/tmp"})," directory.\nKonifer is pre-configured to check this location."]}),"\n",(0,s.jsx)(n.h3,{id:"using-a-ram-disk-tmpfs",children:"Using a RAM disk (tmpfs)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"docker run -d \\\n--name konifer \\\n# Mounts a RAM disk directly to the temp location\n--tmpfs /app/tmp \\\nyour-registry/konifer:latest\n"})}),"\n",(0,s.jsx)(n.h3,{id:"using-outside-volume",children:"Using Outside Volume"}),"\n",(0,s.jsx)(n.p,{children:"Use this if you process massive files that exceed your available RAM."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"docker run -d \\\n  --name konifer \\\n  # Mounts a host directory to the temp location\n  -v /mnt/fast-ssd/konifer-tmp:/app/tmp \\\n  your-registry/konifer:latest\n"})}),"\n",(0,s.jsx)(n.h2,{id:"variant-workers",children:"Variant Workers"}),"\n",(0,s.jsx)(n.p,{children:"Konifer utilizes a bounded thread pool to manage concurrent image transformations. This prevents the server from being\noverwhelmed by a sudden spike in complex transformation requests."}),"\n",(0,s.jsx)(n.h3,{id:"concurrency-limit",children:"Concurrency Limit"}),"\n",(0,s.jsxs)(n.p,{children:["By default, Konifer calculates the worker pool size using the formula: ",(0,s.jsx)(n.code,{children:"Available CPU Cores * 2"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example:"})," On a 4-core system, Konifer initializes 8 Variant Workers."]}),"\n",(0,s.jsx)(n.h3,{id:"configuration",children:"Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["You can manually override the worker count in ",(0,s.jsx)(n.code,{children:"konifer.conf"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-hocon",children:"variant-generation {\n  # Overrides the auto-detection mechanism\n  workers = 10\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"scheduling--priority",children:"Scheduling & Priority"}),"\n",(0,s.jsx)(n.p,{children:"Not all transformations are equal. A user waiting for a webpage to load (On-Demand) is more critical than a background\nthumbnail generation task (Eager)."}),"\n",(0,s.jsx)(n.h3,{id:"priority",children:"Priority"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Synchronous (High Priority)"}),": These are tasks where a client is actively waiting for a response. The request is\nwaiting until processing completes."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"On-Demand Variants"}),"\n",(0,s.jsx)(n.li,{children:"Pre-processing original variants during upload"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Asynchronous (Low Priority)"}),": These are best-effort transformations that occur within an asynchronous context."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Eager variants"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"Fallback Mechanism: If a client requests an Eager Variant that hasn't been processed yet (e.g., due to a long queue)\nor failed to be processed (e.g., the server shutdown with a full queue), Konifer immediately schedules an On-Demand\nvariant task and the respective Eager Variant task is discarded."})}),"\n",(0,s.jsx)(n.h3,{id:"configuring-priority",children:"Configuring Priority"}),"\n",(0,s.jsx)(n.p,{children:"The scheduler uses a probabilistic weighting system. By default, it attempts to dedicate 80% of throughput to\nSynchronous tasks and 20% to Asynchronous tasks."}),"\n",(0,s.jsx)(n.p,{children:"This ensures that background work continues to progress (preventing starvation) without degrading API responsiveness."}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"This wighting is only considered when queues are full. If only Asynchronous tasks are queued, that queue is\npulled from until Synchronous tasks are queued. In other words, the scheduler's algorithm leverages work-stealing."})}),"\n",(0,s.jsx)(n.p,{children:"To change this weighting:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-hocon",children:"variant-generation {\n  # Sets the target allocation for Synchronous tasks (0-100).\n  # Asynchronous allocation is automatically calculated as (100 - synchronous-priority).\n  synchronous-priority = 60\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var r=i(6540);const s={},t=r.createContext(s);function o(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);