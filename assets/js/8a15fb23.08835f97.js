"use strict";(globalThis.webpackChunkkonifer_docs=globalThis.webpackChunkkonifer_docs||[]).push([[161],{2636:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"Reference/image-processing-reference","title":"Image Processing Architecture","description":"Konifer leverages libvips as its underlying transformation engine. Libvips is a","source":"@site/docs/Reference/image-processing.md","sourceDirName":"Reference","slug":"/Reference/image-processing-reference","permalink":"/konifer-docs/Reference/image-processing-reference","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"id":"image-processing-reference","title":"Image Processing Architecture","sidebar_label":"Image Processing"},"sidebar":"docsSidebar","previous":{"title":"Image Transformations","permalink":"/konifer-docs/Reference/image-transformation-reference"},"next":{"title":"Storing Assets","permalink":"/konifer-docs/Reference/reference-variant-storage"}}');var s=i(4848),t=i(8453);const o={sidebar_position:3,id:"image-processing-reference",title:"Image Processing Architecture",sidebar_label:"Image Processing"},a="Image Processing Architecture",c={},l=[{value:"Memory Management",id:"memory-management",level:2},{value:"Variant Workers",id:"variant-workers",level:2},{value:"Concurrency Limit",id:"concurrency-limit",level:3},{value:"Configuration",id:"configuration",level:3},{value:"Scheduling &amp; Priority",id:"scheduling--priority",level:2},{value:"Priority",id:"priority",level:3},{value:"Configuring Priority",id:"configuring-priority",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"image-processing-architecture",children:"Image Processing Architecture"})}),"\n",(0,s.jsxs)(n.p,{children:["Konifer leverages ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://www.libvips.org/",children:"libvips"})})," as its underlying transformation engine. Libvips is a\ndemand-driven, streaming image processing library. Unlike traditional image processors (like ImageMagick), libvips does\nnot load the entire image into memory. Instead, it streams the image in small chunks, processing them via a pipeline."]}),"\n",(0,s.jsx)(n.p,{children:"This architecture allows Konifer to handle large assets (e.g., 100MB+ images) with a very small memory footprint and\nextremely low latency."}),"\n",(0,s.jsx)(n.h2,{id:"memory-management",children:"Memory Management"}),"\n",(0,s.jsx)(n.p,{children:"Because Konifer is a Kotlin application running on the JVM, but libvips is a native C library, memory is managed in two\ndistinct zones:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"JVM Heap:"})," Manages the application logic, HTTP layer, and request metadata."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Native (Off-Heap) Memory:"})," Manages the actual image buffers and pixel data used by libvips."]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["\u26a0\ufe0f ",(0,s.jsx)(n.strong,{children:"Operational Warning: Memory Tuning"}),"\nIncreasing the JVM Heap size (via ",(0,s.jsx)(n.code,{children:"-Xmx"}),") ",(0,s.jsx)(n.strong,{children:"will not"})," help if you are seeing memory pressure during image processing."]}),"\n",(0,s.jsxs)(n.p,{children:["Libvips allocates memory ",(0,s.jsx)(n.strong,{children:"off-heap"}),". If you observe the container running out of memory (OOM), you must increase\nthe total container memory limit, not the JVM heap."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"variant-workers",children:"Variant Workers"}),"\n",(0,s.jsx)(n.p,{children:"Konifer utilizes a bounded thread pool to manage concurrent image transformations. This prevents the server from being\noverwhelmed by a sudden spike in complex transformation requests."}),"\n",(0,s.jsx)(n.h3,{id:"concurrency-limit",children:"Concurrency Limit"}),"\n",(0,s.jsxs)(n.p,{children:["By default, Konifer calculates the worker pool size using the formula: ",(0,s.jsx)(n.code,{children:"Available CPU Cores * 2"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example:"})," On a 4-core system, Konifer initializes ",(0,s.jsx)(n.strong,{children:"8 Variant Workers"}),". This 2x over-provisioning is efficient\nbecause image processing is often I/O bound (reading/writing to the object store), allowing the CPU to switch contexts\nwhile waiting for data."]}),"\n",(0,s.jsx)(n.h3,{id:"configuration",children:"Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["You can manually override the worker count in ",(0,s.jsx)(n.code,{children:"konifer.conf"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json5",children:"variant-generation {\n  # Overrides the auto-detection mechanism\n  workers = 10\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"scheduling--priority",children:"Scheduling & Priority"}),"\n",(0,s.jsx)(n.p,{children:"Not all transformations are equal. A user waiting for a webpage to load (On-Demand) is more critical than a background\nthumbnail generation task (Eager)."}),"\n",(0,s.jsx)(n.h3,{id:"priority",children:"Priority"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Synchronous (High Priority)"}),": These are tasks where a client is actively waiting for a response. The request is\nwaiting until processing completes."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"On-Demand Variants"}),"\n",(0,s.jsx)(n.li,{children:"Pre-processing"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Asynchronous (Low Priority)"}),": These are best-effort transformations that occur within an asynchronous context."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Eager variants"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"\ud83d\udca1 Fallback Mechanism: If a client requests an Eager Variant that hasn't been processed yet (e.g., due to a long queue)\nor failed to be processed (e.g., the server shutdown with a full queue), Konifer immediately schedules an On-Demand\nvariant task and the respective Eager Variant task is discarded."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"configuring-priority",children:"Configuring Priority"}),"\n",(0,s.jsx)(n.p,{children:"The scheduler uses a probabilistic weighting system. By default, it attempts to dedicate 80% of throughput to\nSynchronous tasks and 20% to Asynchronous tasks."}),"\n",(0,s.jsx)(n.p,{children:"This ensures that background work continues to progress (preventing starvation) without degrading API responsiveness."}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": this wighting is only considered when queues are full. If only Asynchronous tasks are queued, that queue is\npulled from until Synchronous tasks are queued. In other words, the scheduler's algorithm leverages work-stealing."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"To change this weighting:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json5",children:"variant-generation {\n  # Sets the target allocation for Synchronous tasks (0-100).\n  # Asynchronous allocation is automatically calculated as (100 - synchronous-priority).\n  synchronous-priority = 60\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var r=i(6540);const s={},t=r.createContext(s);function o(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);